<!DOCTYPE html>
<html>

<!-- *********************** HEAD *********************** -->
<head>
<style type="text/css">
.knitr .inline {
  background-color: #f7f7f7;
  border:solid 1px #B0B0B0;
}
.error {
	font-weight: bold;
	color: #FF0000;
}
.warning {
	font-weight: bold;
}
.message {
	font-style: italic;
}
.source, .output, .warning, .error, .message {
	padding: 0 1em;
  border:solid 1px #F7F7F7;
}
.source {
  background-color: #f5f5f5;
}
.rimage .left {
  text-align: left;
}
.rimage .right {
  text-align: right;
}
.rimage .center {
  text-align: center;
}
.hl.num {
  color: #AF0F91;
}
.hl.str {
  color: #317ECC;
}
.hl.com {
  color: #AD95AF;
  font-style: italic;
}
.hl.opt {
  color: #000000;
}
.hl.std {
  color: #585858;
}
.hl.kwa {
  color: #295F94;
  font-weight: bold;
}
.hl.kwb {
  color: #B05A65;
}
.hl.kwc {
  color: #55aa55;
}
.hl.kwd {
  color: #BC5A65;
  font-weight: bold;
}
</style>
<style type="text/css">
.knitr .inline {
  background-color: #f7f7f7;
  border:solid 1px #B0B0B0;
}
.error {
	font-weight: bold;
	color: #FF0000;
}
.warning {
	font-weight: bold;
}
.message {
	font-style: italic;
}
.source, .output, .warning, .error, .message {
	padding: 0 1em;
  border:solid 1px #F7F7F7;
}
.source {
  background-color: #f5f5f5;
}
.rimage .left {
  text-align: left;
}
.rimage .right {
  text-align: right;
}
.rimage .center {
  text-align: center;
}
.hl.num {
  color: #AF0F91;
}
.hl.str {
  color: #317ECC;
}
.hl.com {
  color: #AD95AF;
  font-style: italic;
}
.hl.opt {
  color: #000000;
}
.hl.std {
  color: #585858;
}
.hl.kwa {
  color: #295F94;
  font-weight: bold;
}
.hl.kwb {
  color: #B05A65;
}
.hl.kwc {
  color: #55aa55;
}
.hl.kwd {
  color: #BC5A65;
  font-weight: bold;
}
</style>
<style type="text/css">
.knitr .inline {
  background-color: #f7f7f7;
  border:solid #B0B0B0;
}
.error {
	font-weight: bold;
	color: #FF0000;
}
.warning {
	font-weight: bold;
}
.message {
	font-style: italic;
}
.source, .output, .warning, .error, .message {
	padding: 0 1em;
  border:solid 1px #F7F7F7;
}
.source {
  background-color: #e0ffff; /*#f5f5f5;*/
}

.output {
  background-color: #ffffe6; 
}

.rimage .left {
  text-align: left;
}
.rimage .right {
  text-align: right;
}
.rimage .center {
  text-align: center;
}
.hl.num {
  color: #AF0F91;
}
.hl.str {
  color: #317ECC;
}
.hl.com {
  color: #AD95AF;
  font-style: italic;
}
.hl.opt {
  color: #000000;
}

/* Font of variable names*/
.hl.std {
  color: #585858;
}
.hl.kwa {
  color: #295F94;
  font-weight: bold;
}
.hl.kwb {
  color: #B05A65;
}
.hl.kwc {
  color: #55aa55;
}
.hl.kwd {
  color: #BC5A65;
  font-weight: bold;
}
</style>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="author" content="Prof. Dr. Johannes Binswanger" />
 
<title>Programming for Practical Data Analysis</title>

<!-- ******* LIBRARIES AND PLUGINS ******* -->

<!-- my own css file -->
<link rel="stylesheet" href="css/baseline.css" type="text/css" />

<!-- jquery, nestedToc, slidesjs ... -->


<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>

<script src="js/jquery-nestedToc.js">// get nestedToc from http://www.jqueryscript.net/menu/Dynamic-Table-of-Contents-Generator-With-jQuery-nestedToc.html
</script>

<script src="js/jquery.slides.min.js"></script>


</head>

<!-- *********************** END OF HEAD *********************** -->

<body>
<!-- ************************************** -->
<!-- AUTOMATIC INSERTION OF "BACK TO TOP"-->
<script>
// Select all headers to prepend "back to top" link.
// However, exclude the first heading, and the author and date
// Do so by creating a class noBackToTop. It is possible to assign multiple classes to an element.
// See http://stackoverflow.com/questions/3015103/jquery-exclude-elements-with-certain-class-in-selector

//NOTE: It is very important to use .before and not .prepend below!!!
// If you use prepend, the TOC gets screwed as the text shows up there as well!!

$(document).ready(function(){
	// Automatic "back to top" before a new heading, but not when the heading is of class noBackToTop, because 
	// there is immediately a subheading
    $(":header:not('.noBackToTop')").before("<p><a href='#docHeader'; style = 'font-size:1em; color: #A0A0A0'>[Back to top]</a></p>");
	// The back to top at the end of the document
	 $(".scriptText").append("<p><a href='#docHeader' style = 'font-size:1em; color: #A0A0A0'>[Back to top]</a></p>");
	 
	 //Horizontal ruler
	 $("h1:not('.noBackToTop')").before("<div class='markEnd'> </div>");
	 
	 
	
});


</script>



<!-- ************************************** 
     **************************************
	 **************************************
	 
-->








<div id="content">

<!-- *********************** TITLE ITEMS *********************** -->

<div id="docHeader">
    <p class="title">Programming for Practical Data Analysis</p>
    <h4 class="author noBackToTop"><em>Johannes Binswanger, University of St. Gallen</em></h4>
    <h4 class="date noBackToTop"><em>Fall 2016</em></h4>
</div> <!-- end of docHeader div -->



<!-- *********************** TABLE OF CONTENT (TOC) *********************** -->

<!-- This contains a toggle button 
and the table of content -->

<div class="tocContainer">
     
<script>
//jQuery code for toggle button
$( document ).ready( function( ) {
$( ".TOCbutton" ).click(function() {
  $( ".tocToggleContainer" ).toggle();
});
});
</script>

<!-- the button -->
<button class="TOCbutton" style="color: #27738C;font-size: 20px;">Show/hide table of content</button>




</div>

<div class="tocToggleContainer">
<!-- This div is empty, for the toggle -->
</div>

<!-- The following div below has the same class as the previous!! And do not forget to add the particular styling about display. Note that the second div contains another div that contains the toc. This is to keep both the toc and the toggle work. It may not be necessary with the particular toc solution chosen here, but it is necessary for other toc solutions.
-->
    <div class="tocToggleContainer" style="display: none">
    <div class = "toc">
        <script>
        // This script is simply copied from 
        // http://www.jqueryscript.net/menu/Dynamic-Table-of-Contents-Generator-With-jQuery-nestedToc.html
        $( document ).ready( function( ) {
        $('.toc').nestedToc({
    
        container: '.scriptText'
    
      });
      });
      </script>
</div>
</div>






<!-- *********************** MAIN DOCUMENT STARTS HERE *********************** -->



<!-- ************************************************************************* -->



<div class = "scriptText"> <!-- This div contains the main text -->








<!-- *********************** INSTALLATION *********************** -->
<h1 id="installation" class="noBackToTop" style = "padding-top: 20px;">How to install R and RStudio</h1>

<p>Below you find two documents that describe in detail how to install R and RStudio on Mac OS X, and on Windows 10. (In Chrome, you may click on the "fit to page" or the zoom buttons to enlarge the documents; in Firefox, you may have to activate Adobe Acrobat; of course, you can easily download the documents onto your hard drive.)</p>

<!-- A4 is  210 × 297, thus the ratio is 1.414-->


<table style="width:100%">

	<tr>
		<th>Installation for Max OS X</th>
	</tr>

  <tr>
    <th>
		<object width="1200" height="850" data="pdfs/Installation Mac OS X.pdf"></object>
	</th>
	</tr>
<!-- Add empty row-->
	<td bgcolor="#FAFAFA" style="line-height:80px;" colspan=1>&nbsp;</td>
<tr>

		<th>Installation for Windows 10</th>
	<tr><th>
		<object width="1200" height="850" data="pdfs/Installation Windows 10.pdf"></object>
    
		
	</th> 

  </tr>
</table>




<h1 id="lecture1" class="noBackToTop">Lecture 1</h1>

<h2 id="lecture1_slides" class="noBackToTop">Slides for Lecture 1</h2>

<p> Below you can find the slides in pdf format for this lecture (which, of course, you can download if you want to make annotations). </p>



<table style="width:100%">

	<tr>
		<th>Slides for Lecture 1</th>
	</tr>

  <tr>
    <th>
		<object width="1200" height="880" data="pdfs/Practical programming - Lecture 1.pdf"></object>
	</th>
	</tr>


</table>


<h2 id="lecture1_codelive">&ldquo;Live&rdquo; code from Lecture 1</h2>

<p>And here you find the R code that we typed during the first lecture. You will also see the respective output from R (on yellow background). You have seen, for a very first time, the following concepts or objects:
<ul>
<li> Variables and the assignment of values to variables
<li> Variable types (numeric, character, logical)
<li> vectors
<li> the commands <code>seq()</code>, <code>rep()</code>, <code>cat()</code>, <code>paste()</code>, <code>paste0()</code>
<li> How to convert numeric values to character values
<li> How to make a very basic plot
</ul>

</p>

<p>Get &ldquo;live&rdquo; code as <a href="pdfs/Lec1_live.pdf" target = "_blank">pdf</a>.</p>

<!--begin.rcode


num = 5
num

alph = "a"
alph

class(num)
class(alph)
# Variables (like num and alph) can have
# several "types", e.g. numeric or character
# This can be checked by using the class command.

numchar = "5"
class(numchar)

# Some algebra
###############

5^2

x = exp(1)
x
y = log(x)
y

# Equality vs. equality, and Boolean variables
##############################################

i = 1
j = i
i = 2
j=i
j 

i = 1
i = i + 1

i <-1
i <-i+1
i

# = means assignment, not mathematical equality

i==j

z = i==j
z
class(z)

# Another data type is "logical", often also 
# called Boolean

# VECTORS
##########

a = c(2,5,90)
a

b = c("w", "o", "w")
b

cat(b)
cat(b, sep="")

# delete a variable
rm(a, b)

# Delete everything in working space

rm(list = ls())

###############################
x = 0:10
x

x = seq(from = 0,
        to = 10, 
        by = 0.5)
x

y = x^2
y

plot(x,y)
plot(x,y, type="l")

rep("Semester",6)

n = as.character(1:6)
n

paste(n, rep(". Semester",6))

paste0(n, rep(". Semester",6))


end.rcode-->




<h2 id="lecture1_homesolution">Solution of Home Assignment for Lecture 1</h2>

<p>Here you find the solution for the home assignment of Lecture 1.</p>

<!--begin.rcode

# Homework Lec1

# Plots of exponential function
##############################

# With a coarse grid
x = seq(0,50, 5)
y = exp(x)
plot(x, y, type = "l")

# With a fine grid
x = seq(0,50, 0.1)
y = exp(x)
plot(x, y, type = "l")

# And with a red curve
plot(x, y, type = "l", col = "red")


# Generating a vector with date information

# There are many possible solutions, here is one:

monthN = c(1:12, 1:12)

years = c(rep("2015", 12), rep("2016", 12))

text = rep(". Monat ", 24)

paste0(monthN, text, years)

end.rcode-->



<h1 id="lecture2">Lecture 2</h1>


<h2 id="lecture2_slides" class="noBackToTop">Slides for Lecture 2</h2>


<table style="width:100%">

	<tr>
		<th>Slides for Lecture 2</th>
	</tr>

  <tr>
    <th>
		<object width="1200" height="880" data="pdfs/Practical programming - Lecture 2.pdf"></object>
	</th>
	</tr>


</table>

<h2 id="lecture2_codelive">&ldquo;Live&rdquo; Code from Lecture 2</h2>

<p>Get &ldquo;live&rdquo; code as <a href="pdfs/Lec2_live.pdf" target = "_blank">pdf</a>.</p>

<!--begin.rcode


# Let's assemble a data.frame (=spreadsheet),
# This can be very big.
# This is the format we will read data into.

n = as.character(1:6)
semester = paste0(n, ". Semester")
semester

# Number of courses
l = length(semester)
l

#generate random vector with zeros and ones

set.seed(1) # Make sure we all draw the same numbers
randZeroOne = rbinom(l, 1, 0.5)

nCourses = 6-randZeroOne
nCourses

# Level of difficulty
diffLevels = c("hard", "medium", "easy")

set.seed(2837482)
difficulty = sample(diffLevels, l, replace = T)
difficulty

class(difficulty)

difficultyFac = as.factor(difficulty)
difficultyFac

#plot(difficulty) # This does not yield any sensible results
plot(difficultyFac)

#number of students
nStud = rpois(l, 30)
nStud


uni = rep("HSG", l)

bachelorProgram = data.frame(
  semester, nCourses, difficultyFac, 
  nStud, uni
)

############################################

# Lists are another data type
L0 = list(bachelorProgram = bachelorProgram,
          difficulty = difficultyFac)

L0

L1 = list(L0, bachelorProgram, "chaos")
L1


end.rcode-->

<h2 id="lecture2_homesolution">Solution of Home Assignment for Lecture 2</h2>


<!--begin.rcode


# Question 1

id = 1:1000

# Question 2

set.seed(8763)
gender = rbinom(1000,1, 0.5)
gender

# Question 3

set.seed(8763)
politViews = rnorm(1000, 5, 1)

hist(politViews)

mean(politViews)

# Question 4

characTypes = c("introvert", "extrovert", "nerdy")

charac = sample(characTypes, 1000, replace = T)

# Question 5

data = data.frame(id, gender, politViews, charac)



end.rcode-->




<!-- ####################################################### -->



<h1 id="lecture3">Lecture 3</h1>



<h2 id="lecture3_codelive" class="noBackToTop">&ldquo;Live&rdquo; Code from Lecture 3</h2>


<p>Please note that the last bits in the &ldquo;live&rdquo; code (under &ldquo;Optional Arguments&rdquo;) is incomplete. We will finish this during Lecture 4. If you prefer the &ldquo;live&rdquo; code as pdf, you can get it <a href="pdfs/Lec3_live.pdf" target = "_blank">here</a>.</p>

<!--begin.rcode

#############
# Functions #
#############

sayHello = function(name){
  paste0("Hello ", name, 
         ", how are you doing today?")
}

sayHello("Sabrina")
sayHello("Christian")

LETTERS

sayHello(LETTERS)




# A function that calculates saving needs for retirement
########################################################

# The input values for the calculation
spending = 5000
interestRate = 4
T = 30

# The stupid way to program... 
# (this does not even deserve the name "programming")

pvSpending = 5000/1.04^30
pvSpending

# A little smarter with using variables

pvSpending = spending/(1+interestRate/100)^T

# The smartest way: Using functions

saveFun = function(x, r, T){
  round(  x/(1+r/100)^T  )
}
saveFun(5000, 0, 30)

# Label arguments
#################

saveFun = function(spending, interestRate,
                   horizon){
    x = spending
    r = interestRate
    T = horizon
  round(  x/(1+r/100)^T  )
}

saveFun(spending = 5000, interestRate = 4,
        horizon = 30)

saveFun(horizon = 30, spending = 5000,
        interestRate = 4)

saveFun(30, 5000, 4)

# With labels you can change the order of the arguments,
# without labels, you cannot.

# Default values
#################

saveFun = function(spending = 5000, 
                   interestRate = 4,
                   horizon = 30){
  x = spending
  r = interestRate
  T = horizon
  round(  x/(1+r/100)^T  )
}

saveFun()

saveFun(spending = 1000)


# Optional arguments
####################

# !!! WARNING: THE CODE BELOW IS INCOMPLETE, 
#     WE WILL FINISH THIS THE NEXT TIME!!!!

saveFun = function(spending = 5000, 
                   interestRate = 4,
                   horizon = 30,
                   get.out.as.text = NULL){
  x = spending
  r = interestRate
  T = horizon
  out = round(  x/(1+r/100)^T  )
  
  if(  !is.null(get.out.as.text)  ){
    cat(sprintf("If you want to spend %s after %s years
and the interest rate is %s percent, 
you have to save %s.", x, T, r, out))
  }
  
  
}

x = 5000; T = 30; r = 4





end.rcode-->



<h2 id="lecture3_homesolution">Solution of Home Assignment for Lecture 3</h2>

<p>The suggested solution for the home assignment of Lecture 3 is available in <a href = "Homework_Lec3.R" download>this script file</a>. Note that there are many other possible solutions, some shorter and more elegant, some a little longer.</p>

<!-- ####################################################### -->



<h1 id="lecture4">Lecture 4</h1>

<p>In this lecture, we start with working on real data. In particular, we will consider data on Swiss Franc exchange rates and how the latter relate to Swiss imports and exports. You need to download the data from the website of the Swiss National Bank to your device before the lecture. You can find the instructions how to do so in <a href = "pdfs/Downloading SNB data and reading CSV files.pdf" target= "_blank">this document</a>.
</p>

<!--
<p>Just in case something really went wrong with downloading the data from the website of the Swiss National Bank, or with reading the data into R, you can get them 
directly in <code>RData</code> format <a href = "data/rawXrates.RData" download>here</a>. Do not open this data by double clicking. Rather copy it into the folder where you have the other data files for this course, and then use the <code>load()</code> command from within an R script.</p>
-->

<!--

<p>In order to progress a little faster during class, I already prepared two R scripts:
<ul>
<li>Completing the savFun function from last time, with an optional argument <a href = "Lec4_forClass1.R" download>[download]</a>
<li>Reading data into R and working with them<a href = "Lec4_forClass2.R" download> [download]</a>
</ul>
</p>
-->



<h2 id="lecture4_codelive" >&ldquo;Live&rdquo; Code from Lecture 4</h2>

<p>If you prefer the &ldquo;live&rdquo; code as pdf, you can get it <a href="pdfs/Lec4_live.pdf" target = "_blank">here</a>.</p>


<!--begin.rcode


############################################
# LECTURE 4, Part 1: Completing function   #
# from last time with an optional argument #
############################################

# During Lecture 3 we worked on a function with an optional
# or "NULL" argument: if the argument get.out.as.text is not NULL,
# then the function saveFun would get the output as text.

# In this function, we introduced two new R functions:
# sprintf, and the conditional.


# sprintf
#########


x = 5000; T = 30; r = 4
out = round(  x/(1+r/100)^T  )
# Note that you can run several commands on one line, 
# separated by semicolons


sprintf("If you want to spend %s after %s years
and the interest rate is %s percent, 
you have to save %s.", x, T, r, out)


# Note: The s in "%s" means "string". See Section 8.2 in 
# "R for Everyone".

# If you want get rid of the editing symbols like "" or \n, you have
# to use the cat function


cat(sprintf("If you want\t to spend %s\n after %s years
and the\n interest\t rate is %s percent, 
you have to save %s.", x, T, r, out))




# Conditionals
##############

# See Chapter 9 in "R for Everyone"

arg = "yes"

if (arg ==  "no"){
  print("I have nothing to say :-(")
}


# So what if arg = "yes"?

arg = "yes"

if (arg ==  "no"){
  print("I have nothing to say :-(")
}

if (arg ==  "yes"){
  print("I have nothing to say :-)")
}


arg = "no"

if (arg ==  "no"){
  print("I have nothing to say :-(")
} else if (arg=="yes"){
  print(":-))")
}
    
# Be very careful with the positions of the curly brackets
# If they are not in the right position, you will get
# an error. This can sometimes be quite tricky.


# Now let's make a function of this

saySomething = function(arg){
  
  #copy/paste from above
  if (arg ==  "no"){
    print("I have nothing to say :-(")
  } else if (arg=="yes"){
    print(":-))")
  }
}

saySomething("no")
saySomething("yes")


# Now we go back to our savings function
########################################

a = NULL
b = "yes"
is.null(a)
is.null(b)

get.out.as.text = "yes"

saveFun = function(spending = 5000, 
                   interestRate = 4,
                   horizon = 30,
                   get.out.as.text = NULL){
  x = spending
  r = interestRate
  T = horizon
  out = round(  x/(1+r/100)^T  )
  
  if (is.null(get.out.as.text)){
    return(out)
    # everything in a function that comes after return is not executed
    # if return is executed...
  
  } else if (get.out.as.text == "yes"){
    cat(sprintf("If you want to spend %s after %s years
and the interest rate is %s percent, 
you have to save %s!", x, T, r, out))
  }
}
  
saveFun()
saveFun(get.out.as.text = "yes")

saveFun(spending = 5000, 
        interestRate = 1,
        horizon = 30,
        get.out.as.text = "yes")

  
saveFun(spending = 5000, 
        interestRate = -0.5,
        horizon = 30)





###########################################################################

###########################################################################


####################################################
# LECTURE 4, Part 2: Reading data from csv files   #
####################################################




# See Section 6.1 and 5.1 in "R for Everyone". 

rm(list = ls())

# Set the working directory to the folder
# where you have the csv files from the SNB


# On a Mac it may look like this
#setwd("/Users/Thomas/Dropbox/Programmierkurs/Data")

# On Windows it may look like this
#setwd("D:/Programmierkurs/Data")

# Note the forward slashes in the directory!!!!!


# Load the data... Which one
# works for you?

rawData = read.csv(file = "data/SNB Xrates downloaded.csv")

rawXrates = read.csv(file = "data/SNB Xrates downloaded clean.csv")

rawXrates = 
  read.csv(file = 
             "data/SNB Xrates downloaded clean.csv", 
           sep = ",")

rawXrates$XX = NA

# In my case, there are still the empty rows and columns. 
# However, even if you do not have them, you can execute 
# the below commands

# What is the type of rawXrates?
class(rawXrates)

# Get the names of the columns ("variables"
# in the statistical sense)
names(rawXrates)

# You can use the names to get a column


head(rawXrates["Date"])

# Use this trick to select only the variables we are interested in

varList = c("Date", "D0", "D1", "Value")

rawXrates = rawXrates[varList]

head(rawXrates)



end.rcode-->


<h2 id="lecture4_homeassignment">Data for Home Assignment for Lecture 4</h2>

<p>Try to get the following data &ldquo;clean&rdquo; into Excel:
<ul>
<li><a href = "data/toImport1.csv" download>Data set 1</a>
<li><a href = "data/toImport2.csv" download>Data set 2</a>
<li><a href = "data/toImport3.csv" download>Data set 3</a>
</ul>
</p>

<p>See StudyNet under &ldquo;Abgabe&rdquo; for further instructions.</p>


<!-- ############################################################### -->


<h1 id="lecture5">Lecture 5</h1>


<h2 id="lecture5_problemsReading" class="noBackToTop">Problems: What if some numbers are automatically converted to dates?</h2>

<p>During Lecture 5, several of you had the problem that some selective values of exchange rates were automatically converted into dates. This produced some rather bizarre-looking graphics of the time series of exchange rates. Furthermore, a few of you also still had problems getting the <code>OECD Main Economic Indicators</code> into R. I will probably write a little more on this later, but here are some quick fixes. Below, I just post the data in <code>RData</code> format. These files have never been opened in Excel, so they should not be infected by the mentioned problems.</p>



<p><ul>
<li><a href = "data/rawXrates.RData" download>SNB exchange rate data</a>
<li><a href = "data/rawExpImp.RData" download>SNB data on exports and imports</a> (for next lecture)
<li><a href = "data/OECD_MEI.RData" download>OECD MEI data</a> (for home assignment)
</ul></p>


<p>Download these data and put them into the folder where you have the other data for this course. Then proceed as follows (adjust the working directory to your own settings):

<!--begin.rcode

setwd("D:/Dropbox/Mac&Surf/Programmierkurs Dropb/Data")

load("rawXrates.RData")
head(rawXrates, 10)

load("rawExpImp.RData")
head(rawExpImp, 10)

load("OECD_MEI.RData")
head(OECD_MEI, 10)

end.rcode -->

<p>You should now be able to run the script file from Lecture 5 with that data (you may have to make some minor adjustments in the code).</p>

<h2 id="lecture5_codelive" >&ldquo;Live&rdquo; Code from Lecture 5</h2>

<p>Get &ldquo;live&rdquo; code as <a href="pdfs/Lec5_live.pdf" target = "_blank">pdf</a>.</p>


<!-- begin.rcode


#############################################
# LECTURE 5: Handling data and data.frames  #
#############################################


# We will continute working with the data sets for the SNB
# That you downloaded for Lecture 4. 

# This time, we are assuming that the data already look neat
# So no deletion of empty columns any more.
 
# Preparatory steps
###################

# Almost everytime you work with data, you should do the 
# following steps...

rm(list = ls()) # Empty workspace to start with a "clean sheet"

# REPLACE THE WORKING DIRECTORY BELOW WITH THE ONE FOR YOUR DEVICE
setwd("D:/Dropbox/Mac&Surf/Programmierkurs Dropb/Data")


# Read the data
###############

# Last time, we read the data like this:
rawXrates = read.csv(
  file = "SNB Xrates downloaded clean noEmptyCol.csv", sep = ",")

# For some of you, sep should take the value ";".

# However, for some of you, the column names may land in the first row,
# which is not the idea. So add "header = TRUE":
rawXrates = read.csv(file = 
   "SNB Xrates downloaded clean noEmptyCol.csv", 
       sep = ",", header = TRUE)



# Referring to columns in data.frames
#####################################

# There are (at least) two ways to refer to a column:

# rawXrates[["D0"]]
# rawXrates$D0

# For instance, you can use this for
# getting all the values in a column

length(unique(rawXrates$D0))
table(rawXrates$D0)


# or the type

class(rawXrates[["D0"]])

# Note the subtle difference between
class(rawXrates[["D0"]])
# and
class(rawXrates["D0"])

# Sometimes, this matters, sometimes not...
# For deleting empty columns, it does not.

# NOTE: Our data is in the so-called "long" format: all variables (in the statistical
# sense) are "stacked".

# The statistical variable names are a combination of D0 and D1.

# The SNB does not make it too easy to get the meaning of D0. But if you go
# to the Data Portal https://data.snb.ch/de/topics/ziredev#!/cube/devkum
# and download the data in Excel format (which, by the way, is useless for 
# reading the data into R), you get the meaning of the exchange rates.


# Converting data from "long" to "wide" and back to "long"
##########################################################

# See "R for Everyone", Section 12.3

# R comes with lots of "packages". For converting data from long to wide
# we need the package "reshape2"

# A package is intalled like this:
# install.packages("reshape2")
# Do this only once on your machine

# Everytime you use a package, you have to "call" or "load" it
library(reshape2)
# or
require(reshape2)


wide = dcast(rawXrates, # the data frame
             Date ~ # the variable that is to
               # 'IDENTIFY' ROWS of new
               # variables! Note the '~'!
               D0 + D1 , # the column(s) containing 
             # what you want to become
             # the new variable NAMES 
             value.var = "Value")  # column that contains the 
              # VALUES of the new variables
              # (often, you can ommit this)

# In short:
wide = dcast(rawXrates, Date ~ D0 + D1)

# Check out, what the following would do:
wide = dcast(rawXrates, Date ~ D0)
wide = dcast(rawXrates, Date ~ D1)


wide = dcast(rawXrates, Date ~ D0 + D1)

# Let's go back to "long". For the moment, this is more useful

long = melt(wide, id.vars = "Date", 
            value.name = "Value")

# D0 and D1 are now merged. We could change this, but
# we have more important things to do...


# Recoding date as numerical, and a unique time identifier
#########################################################

# Our data looks really enormously big
# Let's say we only care about data from 2000 on
# to start with... 

# The next lines of code are preparations for
# data from 2000 on (or any other year)


#install.packages("stringr")
library(stringr)

rawXrates$year = as.numeric(  
  substr(rawXrates$Date, start = 1, stop = 4)  )

rawXrates$month = as.numeric(  
  substr(rawXrates$Date, start = 6, stop = 7)  )


# A unique identifier for time
rawXrates$timeID = rawXrates$year + 
  (rawXrates$month-1)/12



# Eliminating rows and columns from data.frames
# (= selection of subsets of data)
################################################

# Let's get rid of all data before 2000

Xrates = rawXrates

Xrates = Xrates[Xrates$year>=2000, ]

# Now you can see why we needed the dates in numerical format!


# Next we get rid of other information we are not interested in...
unique(Xrates$D0)

Xrates = Xrates[Xrates$D0 == "M0", ]

# Let's select only Euro exchange rates

# How is the EUR coded? For a factor
unique(Xrates$D1)
# does sometimes not work so well. In that case, use
levels(Xrates$D1)

Xrates = Xrates[Xrates$D1 == "EUR1", ]


plot(Xrates$timeID, Xrates$Value, 
     type = "l", col = "red3")



# You can also use the subset command

XratesAlt = subset(rawXrates, 
      year >= 2000 & D0 == "M0"  & D1 == "EUR1",
       select = c(timeID, D1, Value))

# And if we again converted the dates, we could select data >= 2010

# Remove objects we no longer need

rm(long, wide, XratesAlt)


# Analyze the correlation between the USD and EUR exchange rate
###############################################################



data = subset(rawXrates, 
        (D1 == "EUR1" | D1 == "USD1") & 
          D0 == "M0" &
          timeID >= 2000 ,
        select = c("timeID", "D1", "Value"))

# Bring data into wide format
library(reshape2)
data = dcast(data, timeID ~ D1, value.var = "Value")


# Make a plot
matplot(data$timeID, cbind(data$EUR1, data$USD1), 
        type = "l", xlab = "Time", ylab = "EUR, USD", col = c("red3", "turquoise"))
grid()
legend('topright', inset=.05, legend = c("EUR", "USD"),
       lty = 1, col = c("red3", "turquoise"))

# Correlation
cor(data$EUR1, data$USD1)

# Run a regression
reg0 = lm(data$USD1 ~ data$EUR1)
summary(reg0)


end.rcode-->


<!-- ####################################################### -->



<h1 id="lecture6">Lecture 6</h1>

<h2 id="lecture5_homesolution" class="noBackToTop">Solution of Home Assignment for Lecture 5</h2>

<p>The suggested solution for the home assignment of Lecture 5 is as shown below.</p>

<!--begin.rcode


######################
# Homework Lecture 5 #
######################

rm(list = ls())

# SET YOUR WORKING DIRECTORY
setwd("D:/Dropbox/Mac&Surf/Programmierkurs Dropb/Data")

data = read.csv("MEI_20102016213925096.csv", header = TRUE)

# Get first column names, country and variable names
names(data)
unique(data$Country)
unique(data$Subject)

# Use subset to get a restricted data set
x = subset(data, (Country == "Switzerland" |  Country == "Germany" | 
             Country == "OECD - Total") & Frequency == "Monthly",
           select = c("TIME", "Country", "Subject", "Value"))

# The leading indicators series has a very complicated name
# So, instead of typing it, let's just attach a variable to
# it called series using the following trick:
series = unique(x$Subject)[25]

series

# Select the rows that correspond to that series
x = x[x$Subject == series, ]

# Convert to wide format
xWide = dcast(x, TIME ~ Country, value.var = "Value")

xWide



end.rcode-->






<h2 id="lecture6_regression">A Very Brief Introduction into Regression Analysis</h2>


<object width="1200" height="880" data="pdfs/Regression intro.pdf"></object>





<h2 id="lecture6_codelive" >&ldquo;Live&rdquo; Code from Lecture 6</h2>

<p>If you prefer the &ldquo;live&rdquo; code as pdf, you can get it <a href="pdfs/Lec6_live.pdf" target = "_blank">here</a>.</p>


<!--begin.rcode


#############################################
#      LECTURE 6: Data analysis             #
#############################################

# We will first go through (almost) the same steps as in 
# Lecture 5. This time, we will organize the code in a more
# efficient way, such that it becomes more "reusable"
# You will also learn how to merge two data sets.
# The most important thing today are scatter plots
# and regression analysis. These are key tools for
# data analysis.

rm(list = ls()) # Empty workspace to start with a "clean sheet"

# REPLACE THE WORKING DIRECTORY BELOW WITH THE ONE FOR YOUR DEVICE
setwd("D:/Dropbox/Mac&Surf/Programmierkurs Dropb/Data")
#load("rawExpImp (1).RData")

# Read files, adjust file names to your situation!

rawXrates = read.csv(file = 
   "SNB Xrates downloaded clean noEmptyCol.csv")

rawAussen = read.csv(file = 
    "SNB Aussenhandel downloaded clean noEmptyCol.csv")

# If you are having troubles with the data, use the following

# load("rawXrates.RData")
# load("rawExpImp.RData")

# You get these data from the online script on
# https://binswanger.github.io/practicaldata_hs16/#Problems--What-if-some-numbers-are-automatically-converted-to-dates-
# Put these files in your working directory

# SET PARAMETERS HERE!
######################

startYear = 2000
curr = "USD1"
tradeDir = "A"  # Direction of trade
                # Values are E (Einfuhr) 
                # and A (Ausfuhr)
                # run unique(rawAussen$D0) for overview
goodsType = "MAE" # run unique(rawAussen$D1)

measure = "R" # run unique(rawAussen$D2)


unique(rawAussen$D0)
unique(rawAussen$D1)
unique(rawAussen$D2)

# Functions
###########


toGrowth = function(x){
  out = (tail(x, -1)/head(x, -1) -1 )*100
  # This is one element shorter than input, 
  # add an NA as first value
  out = c(NA, out)
  return(out)
}



# Customize the data
####################

# A unique time identifier for BOTH data
library(stringr)

rawXrates$year = as.numeric(  
  substr(rawXrates$Date, start = 1, stop = 4)  )

rawXrates$month = as.numeric(  
  substr(rawXrates$Date, start = 6, stop = 7)  )

rawXrates$timeID = rawXrates$year + 
  (rawXrates$month-1)/12


rawAussen$year = as.numeric(  
  substr(rawAussen$Date, start = 1, stop = 4)  )

rawAussen$month = as.numeric(  
  substr(rawAussen$Date, start = 6, stop = 7)  )

rawAussen$timeID = rawAussen$year + 
  (rawAussen$month-1)/12



xrates = subset(rawXrates, 
        D1 == curr &  # NOTE the apparance of the VARIABLE xrate!!!
           D0 == "M0" &
          timeID >= startYear , # NOTE the apparance of the VARIABLE startYear!!!
        select = c("timeID", "D1", "Value"))

aussen = 
  subset(rawAussen, 
         
         D0 == tradeDir  &  
         D1 == goodsType &
         D2 == measure   &
         timeID >= startYear , 
         
         select = c("timeID", "D0","D1","D2", "Value"))


# Bring data into wide format
library(reshape2)
xrates = dcast(xrates, timeID ~ D1, value.var = "Value")

aussen = dcast(aussen, timeID ~ D0 + D1 + D2, value.var = "Value")

# Merge the two data sets (NEW!!!!)
# DA stands for "Data for Analysis"
DA = merge(xrates, aussen, by = "timeID")
# The "by" argument contains the so-called "key".


# [FOR LATER] convert to growth rates
DA[[curr]] = toGrowth(DA[[curr]])


# ANALYSIS
###########

# Variable name for exports/imports
names(DA)
vn = paste(tradeDir, goodsType, measure, sep = "_")



# Make a plot
plot(DA[[curr]], DA[[vn]], 
        # NOTE: This code works for all types of export/import
        # data and exchange rates!!! They are captured in the 
        # variable names
        
        pch = 16, # data points as dots; google "r plot pch"
     
        cex = .7, # the size of the point (exam question from last semester :-)
     
        xlab = curr, ylab = vn, # axis labels
     
        col = c("turquoise") # color of dots
     
     )  # The closing paranthesis

# Add a regression line

abline(  lm(DA[[vn]]  ~   DA[[curr]]
          ), col="red3", lwd = 3) 



# Run a regression
reg = lm(DA[[vn]]~DA[[curr]])
summary(reg)



# How calculate changes?

test = 1:10
head(test, -1)
tail(test, -1)

dTest = (tail(test, -1)/head(test, -1) -1)*100





end.rcode -->






<h1 id="lecture7">Lecture 7</h1>

<h2 id="lecture7-intro" class="noBackToTop">Introductory remark</h2>


<p>Up to now, you have seen the most important concepts used for analyzing data with R. You have seen many data types, you have seen conditional statements, loops, and, very importantly, functions. You have also learned how to manipulate data frames, and you saw how to produce graphs. You even know how to run regressions and add regression lines to scatter plots.</p>

<p>For the coming lectures, we will focus more on the documentation process of data analysis. We may produce hundreds of graphs and regressions, and we want a format that is convenient for inspecting the results. Moreover, it is the most common thing when analyzing data that you change your mind. You change the definition of your variables, or you want to change the title in your graph etc. etc. Now, if you have produced 300 graphs and regression results, you certainly don't feel like manually going through all of them again and changing them. It would be better to change three lines of code, press a button, and all the 300 graphs, their titles, and the regression tables are spit out according to your new idea. That would be pretty cool! And that's what we want to work on now.</p>


<h2 id="latex" >RMarkdown and Latex</h2>

<p>RStudio has integrated a terrific tool that will achieve this miracle: RMarkdown. In Order to use it, you have install the <code>rmarkdown</code> package and, possibly, also Latex. How this is done is explained in detail in an <a href = "pdfs/RMarkdown&Latex.pdf" target = "_blank">extra document</a>.</p>

<p>
Below you have the code and text that generates <a href = "pdfs/MarkdownIntro.pdf" target = "_blank">this document (pdf version)</a>. It explains the most important features of RMarkdown. Just inspect the code to see how the formatting, the R code chunks and R output is generated. It's pretty self-explaining.
</p>


<pre style="margin-left:50px; padding:10px;
background-color:#ffe6e6;"><code>


---
title: "A Very Short Introduction to R Markdown by Example"
author: "Johannes Binswanger"
date: "November 24, 2016"
output: pdf_document
---

# What this document is about

Let's start this text with an important warning. In the so-called YAML header that configures this
`Rmd` file, you see the `date` item. If you happen to use a German date format there with a period
after the number, like `24. November 2016`, then the compilation to *pdf* will not work. However, it
works if you set it to `24\\. November 2016`. It can easily be that the date is automatically set to
a German format if you open a new Rmarkdown file in RStudio.

If you want to spellcheck your text, put the cursor at the beginning of the chunk of text that
you want to check and then press the little green checking symbol with "ABC" on top in the taskbar
in the upper left corner of the RMarkdown document. The rest is self-explaining.


# The most important elements for text editing

## Links

Let's start with links. You use a link by placing it inside `<>`. A very useful link goes
to the R Markdown cheatsheets. The one in English can be found under
<https://www.rstudio.com/wp-content/uploads/2015/02/rmarkdown-cheatsheet.pdf>.
If you find this lengthy link to clumsy, here is a more elegant example: 

* Please find the link to the German cheatsheet [here](https://www.rstudio.com/wp-content/uploads/2015/06/rmarkdown-german.pdf).

A very useful link is [this one](http://rmarkdown.rstudio.com/)!

## More on headings

You can generating heading *x* by placing *x* hashtags (e.g. `##` for heading 2) in
front of the heading text.

## More formatting elements

You can put text in *italics* by writing `*italics*`. And you put it in **bold** with `**bold**`. 
If you want to have code appear as `code`, put it inside these little apostrophes ` `.
  
A unnumbered list looks like this:

* First item
* Second item
* Third item

**Make sure that there is an empty line before the list!** Otherwise, it looks different. 
A numbered list looks like this

1. First item
2. Second item
3. Third item

Again, include an empty line before the list

## Mathematical expressions

You can use mathematical expressions by using Latex syntax (see e.g. 
<https://www.sharelatex.com/learn/Mathematical_expressions>). Let's 
copy a chunk of text from that webpage:

>The well known Pythagorean theorem \(x^2 + y^2 = z^2\) was 
proved to be invalid for other exponents. 
Meaning the next equation has no integer solutions:
 
>\[ x^n + y^n = z^n \]


Note that I used the blockquote formatting for the quote from the sharelatex webpage. 
The blockquote syntax is just `>`, extremely simple! Again, insert an empty line before.

You can also do it like this:
\begin{equation}
  \int_{-\infty}^{\infty}xf(x)dx= 1.
\end{equation}



# How to include R 

Now it is time to include output from R.

Here is a chunk of code that is visible in the output document. (**Adjust the working 
directory to your situation!**)


```{r}

# Load data.
# We first use the full (absolute) path,
# in order to avoid setwd()
# ADJUST IT TO YOUR SITUATION

load("D:/Dropbox/Mac&Surf/Programmierkurs Dropb/Data/dataForAnalysis.RData") 

# And some output
names(dataAussen)
unique(dataAussen$D1)

```



You can also try to use `setwd()`:
```{r}
setwd("D:/Dropbox/Mac&Surf/Programmierkurs Dropb/Data")
load("dataForAnalysis.RData") # Load data

# And some output
ls()

```

However, `setwd()` does not always work. If neither the full path for loading the data works, 
nor `setwd()`, then put your markdown file in the same folder as where you have your data.

In any case, changing the working directory via `setwd()` always produces a warning message. 
Nevertheless, I personally use it whenever it is convenient (and when it happens to work).

Here is something very important to realize:

>**The working directory of R Markdown is quite separate from R. R Markdown often has no clue what 
the current working directory is of your R session. It's really two separate things.**

Now let's repeat the first chunk of code, but with an additional argument added to `{r}`, namely 
`{r, echo = FALSE}`:

```{r, echo = FALSE}

setwd("D:/Dropbox/Mac&Surf/Programmierkurs Dropb/Data")
load("dataForAnalysis.RData") # Load data

# And some output
names(dataAussen)
unique(dataAussen$D1)

```

You see that the code that generates the output is no longer shown. You can also do exactly the 
opposite, i.e. show the code but suppress the output using `{r, eval = FALSE}`

```{r, eval = FALSE}

load("dataForAnalysis.RData") # Load data

# And some output
names(dataAussen)
unique(dataAussen$D1)

```

No output is shown in this case.

## Including output from R in the text

Suppose we want to talk of the mean of a variable in the text. We can directly include R expressions 
in the text using `<apostrophe> r <expression> <apostrophe>`. The following blockquote contains an example.

>The mean of the variable `r unique(dataXrates$D1)[2]` is 
`r mean(
    dataXrates$Value[dataXrates$D1==unique(dataXrates$D1)[2]], 
    na.rm = TRUE)`. 
Or, rounded to only 2 digits, this is
`r round(mean(
    dataXrates$Value[dataXrates$D1==unique(dataXrates$D1)[2]], 
    na.rm = TRUE), digits = 2)`. 
    
Note that you can still interactively evalue R expressions inside an R Markdown document by selecting 
the expression and hitting `control/command + Enter`. That is very convenient.


## Including graphs

Here is how to include a graph (without the generating code):

```{r, echo = FALSE}

plot(unique(dataXrates$timeID), dataXrates$Value[dataXrates$D1==unique(dataXrates$D1)[2]],
     type = "l", col = "red3", xlab = "Month", ylab = unique(dataXrates$D1)[2],
     main = "Die Entwicklung des Britischen Pfunds", cex.main = 0.7)

```

# More sophisticated formatting

So far, our document looks reasonably good in both html and pdf. If you want to go for more 
sophisticated formatting, you often have to make a choice. The reason is that you will need syntax 
that is specific to either html or latex. Quite often, latex and pdf is the better choice, or at least 
the more convenient one. You will see examples of how to use latex code in `Lec7_AnalysInMarkdown.Rmd` 
and `getAnalysis.R`. Important instances are tables and colored text.


</code></pre>



<h2 id="lecture7_codelive" >&ldquo;Live&rdquo; Code from Lecture 7</h2>

<p>Get &ldquo;live&rdquo; code as <a href="pdfs/Lec7_live.pdf" target = "_blank">pdf</a>.</p>




<!--begin.rcode


#####################################################################
# LECTURE 7: Giving better names to economic variables in SNB data  #
#####################################################################

# This is the first of a series of scripts for Lecture 7.
# In this script, we "dress up" our SNB data and then save them
# To the hard disk directly in RData and csv format. So we can use them
# next time cirectly, without any dressing up.

rm(list = ls())

# Read the data as they come from the SNB website
#################################################

# REPLACE THE WORKING DIRECTORY BELOW WITH THE ONE FOR YOUR DEVICE
setwd("D:/Dropbox/Mac&Surf/Programmierkurs Dropb/Data")



# Read files, adjust file names to your situation!
rawXrates = read.csv(file = 
   "SNB Xrates downloaded clean noEmptyCol.csv")

rawAussen = read.csv(file = 
    "SNB Aussenhandel downloaded clean noEmptyCol.csv")

# If you are having troubles with the data, use the following two lines

# load("rawXrates.RData")
# load("rawExpImp.RData"); rawAussen = rawExpImp; rm(rawExpImp)

# You get these data in RData format from the online script on
# https://binswanger.github.io/practicaldata_hs16/#Problems--What-if-some-numbers-are-automatically-converted-to-dates-
# Put these files in your working directory

# Give better name to the "economic variables"
##############################################

# First for rawAussen

# Make a copy of rawAussen
dataAussen = rawAussen

#rename Do
oldNamesA_D0 = unique(as.character(dataAussen$D0))
  # use "as.character", so we really know what we are doing, factors are tricky
newNamesA_D0 = c("Einfuhr", "Ausfuhr", "Handelsbilanzsaldo")
#check
cbind(oldNamesA_D0, newNamesA_D0)

# # For developing the function
# df = dataAussen
# colInDf = "D0"
# oldNames = oldNamesA_D0
# newNames = newNamesA_D0

# A function for renaming, so we need to type this 3 times...
rename = function(df, colInDf, oldNames, newNames){
  # In case that the column where we want to change names is a factor
  # first convert the factor to character. Otherwise, it becomes a bit more tricky
  if (is.factor(df[[colInDf]])) {
    df[[colInDf]] = as.character(df[[colInDf]])
  }
  
  # Now rename
  for (i in 1:length(oldNames)){
    df[[colInDf]]   [df[[colInDf]] == oldNames[i]] = newNames[i]
    #dataAussen[["D0"]]  [dataAussen[["D0"]] == "E"]
    #dataAussen$D0   [dataAussen$D0 == "E"]
  }
  return(df)
}

dataAussen = rename(dataAussen, "D0", oldNamesA_D0, newNamesA_D0)

# rename D1

oldNamesA_D1 = unique(as.character(dataAussen$D1))
newNamesA_D1= c("Total", "Maschinen, Apparate und Elektronik", 
              "Praezisionsinstrumente, Uhren, Bijouterie",
              "Chemikalien", "Textilien, Bekleidung, Schuhe",
              "Fahrzeuge", "Metalle", "Uhren", "Praezisionsinstrumente",
              "Praezisionsinstrumente, Uhren, Bijouterie")

# Check            
cbind(oldNamesA_D1, newNamesA_D1)
                            
dataAussen = rename(dataAussen, "D1", oldNamesA_D1, newNamesA_D1)

oldNamesA_D2 = unique(as.character(dataAussen$D2))
newNamesA_D2= c("Wert in Millionen Franken", 
              "Veraenderung gegenueber dem Vorjahr in \u0025 - nominal",
              "Veraenderung gegenueber dem Vorjahr in \u0025 - real")

# "u0025" is UTF-8 coding

# Check            
cbind(oldNamesA_D2, newNamesA_D2)

dataAussen = rename(dataAussen, "D2", oldNamesA_D2, newNamesA_D2)

# Now the exchange rates

# Copy the data to new data frame
# get rid of end-of-month values of exchange rates
dataXrates = rawXrates[rawXrates$D0 == "M0", ]

oldNamesX_D1 = unique(as.character(dataXrates$D1))

newNamesX_D1 = c(
    "CHF/Euro",
    "CHF/Britisches Pfund",
    "CHF/100 Daenische Kronen",
    "CHF/100 Norwegische Kronen",
    "CHF/100 Tschechische Kronen",
    "CHF/100 Ungarische Forint",
    "CHF/100 Polnische Zloty",
    "CHF/100 Rubel",
    "CHF/100 Schwedische Kronen",
    "CHF/100 Tuerkische Lira",
    "CHF/US Dollar",
    "CHF/Kanadische Dollar",
    "CHF/100 Argentinische Pesos",
    "CHF/100 Brasilianische Real",
    "CHF/100 Mexikanische Pesos",
    "CHF/Suedafrikanischer Rand",
    "CHF/100 Japanische Yen",
    "CHF/Australischer Dollar",
    "CHF/100 Chinesische Yuan",
    "CHF/100 Hongkong Dollars",
    "CHF/100 Koreanische Won",
    "CHF/100 Malaysische Ringgit",
    "CHF/Neuseeländischer Dollar",
    "CHF/100 Singapur-Dollars",
    "CHF/100 Thailaendische Baht",
    "CHF/Sonderziehungsrecht")

  
# Check            
cbind(oldNamesX_D1, newNamesX_D1)

dataXrates = rename(dataXrates, "D1", oldNamesX_D1, newNamesX_D1)

# Create unique timeIDs
#######################

library(stringr)

calcTimeID = function(df){
  
  df$year = as.numeric(  
    substr(df$Date, start = 1, stop = 4)  )

  df$month = as.numeric(  
    substr(df$Date, start = 6, stop = 7)  )
  
  df$timeID = df$year + 
    (df$month-1)/12
  
  df$year = NULL
  df$month = NULL
  
  return(df)
}

dataAussen = calcTimeID(dataAussen)
dataXrates = calcTimeID(dataXrates)


# Save data in RData format
save(dataAussen, dataXrates,
     file = "dataforAnalysis.RData")


# Write data to csv (just for fun)

write.table(dataAussen, file = "dataAussen.csv", 
            sep = ",", qmethod = "escape", na = "",
            row.names = FALSE)

write.table(dataXrates, file = "dataXrates.csv", 
            sep = ",", qmethod = "escape", na = "",
            row.names = FALSE)


end.rcode-->






<h1 id="lecture8">Lecture 8</h1>


<h2 id="lecture8_codelive" class="noBackToTop">&ldquo;Live&rdquo; code from Lecture 8</h2>


<p>In Lecture 8 we considered a larger number of scripts, as well as the function <code>getAnalysis()</code>. The scripts do all very similar things. Essentially, I wanted to proceed step by step to illustrate how the function <code>getAnalysis()</code> emerges from more script-like code. The first time you see a function that has more than 100 lines and does many things at once, it can feel a bit intimidating. Therefore this step-by-step procedure. Below, I only post the code of the function <code>getAnalysis()</code> and then a script that uses that function. You can see all code from Lecture 8 in <a href = "pdfs/Lec8_live.pdf" target = "_blank">this document</a>.</p>

<p> So this is the code for the function (the most complicated you have seen so far).</p>
<!--begin.rcode, eval = FALSE



getAnalysis = function(currency, tradeDirection, typeOfGoods, measure,
                       startYear = 2000, dataAsChangeRates = "yes", 
                       saveGraph = "no"){
  
  # To make function variables nice and understandable,
  # but keep variables in function definition code
  # a bit shorter
  
  curr=currency; tradeDir= tradeDirection; 
  goodsType = typeOfGoods
  
  # END ADDED TO Lec7_forClass_Analysis1.R !!!!
  
  
  toGrowth = function(x){
    out = (tail(x, -1)/head(x, -1) -1 )*100
    out = c(NA, out)
    return(out)
  }
  
  # Select the subset of rows and columns from 
  # dataAussen and dataXrates that we need,
  # assign new name to resulting object.
  
  aussen = 
    subset(dataAussen, 
           
           D0 == tradeDir  &  
             D1 == goodsType &
             D2 == measure   &
             timeID >= startYear , 
           
           select = c("timeID", "D0","D1","D2", "Value"))
  
  xrates = 
    subset(dataXrates, 
           D1 == curr  & 
             timeID >= startYear,
           select = c("timeID", "D1","Value"))
  
  
  # Bring data into wide format
  library(reshape2)
  xrates = dcast(xrates, timeID ~ D1, value.var = "Value")
  
  aussen = dcast(aussen, timeID ~ D0 + D1 + D2, value.var = "Value")
  
  # !!!!! QUITE SOME NEW STUFF FROM HERE ON !!!!!
  # make variable name for variable in "aussen" prettier,
  # such that we can use it for labels in graphs
  # In particular, we do not want the underscores
  # and not "in Millionen Franken".
  
  library(stringr) 
  # library to work on character ("string") variables
  
  x = str_locate_all(names(aussen)[2], "_") # find ALL positions of underscores
  class(x) # x is a list
  x = max(x[[1]])  # the LAST position of an underscore, use [[]]
  # to extract elements from lists
  
  # cut off the pieces after the last underscore
  # ("Wert in Millionen Franken")
  newName = substr(names(aussen)[2], start = 1, stop = x-1)
  
  # and replace the remaining underscore(s)
  newName = str_replace_all(newName, "_", " - ")
  
  # Assign the new name to second column in "aussen".
  
  names(aussen)[2] = newName
  
  # NOTE: All this code works for ANY type of export/import variable
  # we may want to analyse. It is GENERIC. That's why it's a little 
  # tedious to write, but it ALWAYS works.
  # Compare this to a "manual" specific adjustment without the stringr
  # commands. This would only work for ONE SPECIFIC case, not ALL!!!
  
  
  # Now merge the two data sets 
  D = merge(xrates, aussen, by = "timeID")
  # D is my shortcut for Data we analyse
  
  # rename "timeID" to something that looks pretty 
  # in a graph
  names(D)[1] = "Zeit"
  
  
  
  # convert to rate of change, if required
  # by parameter dataAsChangeRates
  
  # For this to work for any of our potential variables
  # we need a generic names for the thing in the third column of D.
  # In the regression analysis, this will be our y-variable.
  yvar = names(D)[3]
  
  # convert to percentage changes
  if (dataAsChangeRates == "yes") {
    D[[curr]] = toGrowth(D[[curr]])
    D[[yvar]] = toGrowth(D[[yvar]])
  }
  
  # # This is only for inspections of the data
  # # for potentially later use
  # hist(D[[curr]] )
  # max(D[[curr]], na.rm = T )
  # which.max(D[[curr]])
  
  
  # One more piece about the variable names
  # to make them useful for labels in graphs.
  # If we change the data to percentage changes
  # we want to be able to get this in the graphs
  # from the labels, otherwise, we may forget 
  # whether we plotted levels or change rates
  
  addToLab = ""  # initialize an empty character variable
  
  # make it nonempty in case that we convert data to 
  # percentage changes
  if (dataAsChangeRates == "yes"){
    addToLab = "(Veraenderung in \u0025)"
  }
  addToLab
  
  # the "\u0025" code is an example of UTF-8 encoding
  # See http://www.utf8-chartable.de/unicode-utf8-table.pl?utf8=oct&unicodeinhtml=dec&htmlent=1
  
  
  
  
  # Preparing orderly file names
  # for option of saving graphs to file
  ######################################
  
  # Create a folder inside your working directory,
  # call it plots
  
  # We want to have file names that indicate all parameters, such
  # as "CHFproEuro_Ausfuhr_Total_WertNom_Veraend"
  # If you then want to select a few graphs for
  # your document (e.g. thesis), you can quickly identify
  # the one you want.
  # This code is run ONLY IF saveGraph is "yes"
  if (saveGraph=="yes"){
    x = "" # This is becoming the piece that replaces
    # "Wert in Millionen Franken", in case that
    # measure takes on this value.
    # Otherwise, x stays empty (i.e. "")
    if (measure == "Wert in Millionen Franken"){
      x = "WertNom"
      if (dataAsChangeRates == "yes"){
        x = paste0(x, "_Veraend")
        # if data are converted to percentage changes
        # add this to x
      }
    }
    # Now put all the pieces together, separated by
    # underscores, which are practical for the purpose
    # of file names
    fname = paste(curr, tradeDir, goodsType, x, sep = "_")
    # There is still a forward slash. This can be a problem for
    # file names, so replace it with something else
    fname = str_replace(fname, "/", "pro")
    
    # This is the command that actually initiating the process of
    # writing to a png file
    # note that addition of "plots/", meaning that the file 
    # should go into the plot folder. Also not the ".png".
    png(filename = paste0("plots/", fname, ".png"), width = 800, height = 800)
  }
  
  
  
  
  
  # ANALYSIS
  ###########
  
  
  # Make a plot
  
  # !!!NEW!!!
  par(mar=c(5, 6, 4, 2) + 0.1)
  # par() is used to set graphical parameters.
  # In this case, our aim is to set the parameters
  # of the margain of the graph. We want to have space for 3 lines
  # of text on the left side, instead of only one!
  # We want to indicate the full characterization of our
  # y variable along the y axis.
  
  # mar consists of a numerical vector of the form 
  # c(bottom, left, top, right) which gives the number of lines 
  # of margin to be specified on the four sides of the plot. 
  # The default is c(5, 4, 4, 2) + 0.1.
  
  
  plot(D[[curr]], D[[yvar]], 
       
       pch = 16, # data points as dots; google "r plot pch"
       
       cex = .7, # the size of the points
       
       xlab = paste(curr, addToLab, sep = " "),
       
       ylab = paste(tradeDir, goodsType, addToLab, sep = "\n"),
       # Note, here we use "\n" as a separater between the 
       # arguments of paste. This means a line break! 
       
       col = c("turquoise"), # color of dots
       
       main = paste0(tradeDir, " (", goodsType, ") \nund ",
                     curr, "-Wechselkurs")
       # The title of the graph.
       # Note the line break!
       
  )  # The closing parenthesis of plot
  
  grid()  # add grid lines, so it is easier to judge the slope of 
  # the regression line we will add next.
  
  # Add a regression line
  abline(  lm(D[[yvar]]  ~   D[[curr]]
  ), col="red3", lwd = 3) 
  
  # If we wrote the plot to a png file, we 
  # have to "close that channel" to return to
  # the normal output mode.
  # This is done with the next line of code.
  if (saveGraph=="yes") dev.off()
  
  # Now e also run a regression
  # explicitly, so we can get the estimated
  # parameters
  reg = lm(D[[yvar]]~D[[curr]])
  # Save the regression as an object called "reg"
  s = summary(reg)
  # This gives us the estimated parameters
  
  class(s) # This is a new type of object
  
  s$coefficients
  class(s$coefficients) # This is what we actually want
  # It's just a matrixm you can 
  # give it row and column names
  
  rownames(s$coefficients)
  colnames(s$coefficients)
  
  # For a nice table in a document, these
  # names look ugly. So let's change them
  
  rownames(s$coefficients) = c("Konstante", curr)
  colnames(s$coefficients)[1:3] = c("Koeffizient", "Standardfehler",
                                    "t-Wert")

  
  cat("Die zugehoerige Regressionstabelle sieht wie folgt aus.\n\n")
  
  library(xtable)
  options(xtable.comment = FALSE)
  tab = xtable(s)
  print(tab, type="latex")
  
  # This one looks a bit weird. You are going to see later...
  cat("\n\nDas $R^2$ betraegt ", round(s$r.squared, digits = 4), ".", sep = "")
  
  # Since s$coefficients is just a matrix
  # we can easily extract the pvalue that tells us
  # whether the estimated relationship is statistically significant
  pval = s$coefficients[2,4]
  
  # The below looks also weird. Can you guess what it is
  # supposed to do?
  if (pval<00.05){
    cat("\\textcolor{red}{Die Beziehung ist statistisch signifikant!}")
  } else {
    cat("\\textcolor{blue}{Wir haben hier keine statistisch
        signifikante Beziehung.}")
}
  
  
  
  
  
  
  } # closing curly bracket of function definition 


end.rcode-->



<p>And here you see examples of how to call the function. In fact, we use it in a loop to generate a large number of image files.</p>


<!--begin.rcode, eval = FALSE

rm(list = ls()) # Empty workspace to start with a "clean sheet"

# REPLACE THE WORKING DIRECTORY BELOW WITH THE ONE FOR YOUR DEVICE
setwd("/Users/Johannes/Dropbox/Mac&Surf/Programmierkurs Dropb/Data")


load("dataForAnalysis.RData")

# NEW!!!
# This is how you call a function that you define in a
# separate file!
# It's like you wrote your own "package" and call it here!!!
source("../R_Scripts/getAnalysis.R")

# Note on the path above:
# This is the example of a RELATIVE path

# My working directory is
# "D:/Dropbox/Mac&Surf/Programmierkurs Dropb/Data"
# This is where I have the data. However, my R scripts
# are in a different directory:
# "D:/Dropbox/Mac&Surf/Programmierkurs Dropb/R_Scripts"
# So, starting from the Data directory, I have to go 
# one directory up, and then down to R_Scripts.
# This is what "../R_Scripts/getAnalysis.R" means.


getAnalysis(currency = unique(dataXrates$D1)[2], 
            tradeDirection = "Ausfuhr", 
            typeOfGoods = "Total", 
            measure = "Wert in Millionen Franken",
            saveGraph = "yes"
)

# Now we want to start massproduction of graphs!
# Create a folder inside your working directory,
# call it plots

typeList = unique(dataAussen$D1[dataAussen$D0 == "Ausfuhr"])
# This is a list we want to loop over to get all the
# respective plots
# Note that not all values in dataAussen$D1 are available for 
# "Ausfuhr". Some are only available for "Einfuhr". This
# explains the slightly more involved code above.

for (i in typeList){
  getAnalysis(currency = unique(dataXrates$D1)[1], 
              tradeDirection = "Ausfuhr", 
              typeOfGoods = i, 
              measure = "Wert in Millionen Franken",
              saveGraph = "yes"   # TURN THIS ON!!!!
  )
}










# If you are not yet impressed, then lets expand capacity!


currList = unique(dataXrates$D1)


for (i in currList){
  for (j in typeList[2:length(typeList)]){
    
    currency = i
    tradeDirection = "Ausfuhr"
    typeOfGoods = j 
    
    cat("\\subsection{Reaktion von ", tradeDirection,
        " (", typeOfGoods, ") auf ", currency,
        "-Wechselkurs}", sep = "")
    
    getAnalysis(currency, 
                tradeDirection, 
                typeOfGoods, 
                measure = "Wert in Millionen Franken",
                saveGraph = "yes"
    )
  }
}



# The best way to inspect the output is to open a new word document 
# and drag the files into that document from the file explorer/finder.  


# This is all pretty cool. There is one drawback of this procedure, 
# however. We cannot automate any text comments on our results,
# nor automate the printing and commenting of regression results.

# In order to automate documentation further, we need an additional
# tool: RMarkdown!


end.rcode-->




<h1 id="lecture9">Lecture 9</h1>

<p>In Lecture 9, we let go the final firework of this course: a relatively short markdown file, repeatedly calling the function <code>getAnalysis()</code> within loops that produces a 
<a href = "pdfs/Lec7_AnalysInMarkdown.pdf" target = "_blank">pdf document</a> of 320 pages in 30 seconds! The document show the analysis of the relationship between all export/import items in our data and all exchange rates. Mind the results shown on pages 63-68 of the pdf document. The graphs should make you suspicious. A piece of code posted below shows that the units of measurement of the Turkish Lira changed in 2005!
</p>

<p>Here is the markdown code that produces the document (do not forget to adjust the working directory and <code>source</code> path for the call of the function <code>getAnalysis()</code>. You find the code for the latter posted in the previous Lecture.</p>


<pre style="margin-left:50px; padding:10px;
background-color:#ffe6e6;"><code>

---
title: Beziehung zwischen Schweizer Exporten und Importen und dem Wert des Schweizer
  Frankens
author: "Johannes Binswanger"
date: "16\\. November 2016"
output:
  pdf_document:
    keep_tex: yes
  html_document: default
  # This is for html
  word_document: default
header-includes: \usepackage{xcolor}
---



<!--
Here starts to main body of the document. This part is edited in markdown,
except for the code chunks highlighted in gray below.

In the main body, comments are indicated in html-style,
i.e. by 

      <!-- blah blah -->

<!-- Do not use # here. In Markdown, this means a header! 

This document gives you a template on how to use Rmarkdown
for the automated production of the output from analytics
work. Output formats can be pdf or html, and to a limited degree, also
word. Below, we focus on pdf, which is particularly useful in practice.
One reason why pdf is more useful than html (if you have to make a
choice) is that it is easier to write comments into a pdf than into
a html document. And comments are essential for productive
collaboration!

In order to totally confuse you, the below r code chunks also contain
latex code. In other words, this is a perfect example of some
programming kauderwelsch...
-->

```{r, echo=FALSE, comment = "", warning=FALSE, results = "asis"}

# Everything inside ```{...}``` (and highlighted gray) is code evaluated in R. 
# Everything outside ```{...}``` is NOT R code but Markdown code.

# The commands inside the curly brackets set parameters.
# echo = FALSE means that the code that produces the output (such as setwd() etc.)
# is not shown in the output document. You can set echo = TRUE and
# see what happens. 
# As for the comment command, check it out what happens if you ommit
# that piece (I personally don't like it).
# warning = FALSE means that the output does not shown any warnings, such as
#   "Warning: package 'xtable' was built under R version 3.3.2"


# result = "asis" is there to confuse you even more. It means that the pieces 
# or characters inside the cat function below are read as latex code if
# the document is compiled to pdf. 
# (It would be read as html code if the document were compiled
# to html. But html uses a different syntax, so we would have to 
# change it, which we do not consider for now.)


# The below commands are really like in 
# an R script!

rm(list = ls()) 

# REPLACE THE WORKING DIRECTORY BELOW WITH THE ONE FOR YOUR DEVICE
setwd("D:/Dropbox/Mac&Surf/Programmierkurs Dropb/Data")

load("dataForAnalysis.RData")

# ADJUST PATHS TO YOUR SITUATION
source("../R_Scripts/getAnalysis.R")

library(xtable)

cat("\\section{Ein erstes Beispiel}")
# This is a first example of latex code.
# In latex you woudl actually use 
# \section{Ein erstes Beispiel
# In a RMarkdown document, you have to replace
# all backslashes by double backslashes. 
# Windows users already know this from setwd().



getAnalysis(currency = unique(dataXrates$D1)[1], 
                tradeDirection = "Ausfuhr", 
                typeOfGoods = unique(dataAussen$D1)[1], 
                measure = "Wert in Millionen Franken"
    )

```



```{r, echo=FALSE, comment = "", results = "asis", eval = TRUE}

# A first example of mass production in RMarkdown...
# But now it's not just about producing figures.
# Have a look at the output and try to infer what's going
# on!!

typeList = unique(dataAussen$D1[dataAussen$D0 == "Ausfuhr"])
currList = unique(dataXrates$D1)

cat("\\newpage")  
      # The latex command for starting a new page

cat("\\section{Reaktion der Schweizer Exporte auf Veraenderungen im Wert
    des Schweizer Frankens}")
      # Latex command for starting a new section

# start th loop over typeList
for (j in typeList){
  currency = unique(dataXrates$D1)[1]
  tradeDirection = "Ausfuhr"
  typeOfGoods = j 

  # Subtitles inside the loop, generated automatically.
  # Isn't that cool?
  
  cat("\\subsection{Reaktion von ", tradeDirection, 
      " (", typeOfGoods, ") auf ", currency,
      "-Wechselkurs}", sep = "")
  # \subsection in Latex is comparable to Heading 2 in MS Word
  
  
  
  getAnalysis(currency, 
              tradeDirection, 
              typeOfGoods, 
              measure = "Wert in Millionen Franken"
  )
}


```




```{r, echo=FALSE, comment = "", results = "asis", eval = TRUE}

# Now we loop over both export items and currencies!

typeList = unique(dataAussen$D1[dataAussen$D0 == "Ausfuhr"])
currList = unique(dataXrates$D1)

cat("\\newpage")
cat("\\section{Reaktion der Schweizer Exporte auf Veraenderungen im Wert
    des Schweizer Frankens im Verhaeltnis zu weiteren Waehrungen}")

for (i in currList){
  for (j in typeList[2:length(typeList)]){
    
  currency = i
  tradeDirection = "Ausfuhr"
  typeOfGoods = j 
    
  cat("\\subsection{Reaktion von ", tradeDirection,
      " (", typeOfGoods, ") auf ", currency,
      "-Wechselkurs}", sep = "")
  
    getAnalysis(currency, 
                tradeDirection, 
                typeOfGoods, 
                measure = "Wert in Millionen Franken"
    )
  }
}

```







```{r, echo=FALSE, comment = "", eval = TRUE, , results = "asis"}

# And finally the results for imports, for all items and all currencies

cat("\\newpage")
cat("\\section{Reaktion der Schweizer Importe auf Veraenderungen im Wert
    des Schweizer Frankens}")

typeList = unique(dataAussen$D1[dataAussen$D0 == "Einfuhr"])

for (i in currList){
  for (j in typeList){
    
  currency = i
  tradeDirection = "Einfuhr"
  typeOfGoods = j 
    
  cat("\\subsection{Reaktion von ", tradeDirection,
      " (", typeOfGoods, ") auf ", currency,
      "-Wechselkurs}", sep = "")
  
    getAnalysis(currency, 
                tradeDirection, 
                typeOfGoods, 
                measure = "Wert in Millionen Franken"
    )
  }
}

```


</code></pre>

<p>Here is the code that allows you to inspect what's wrong with the Turkish Lira.</p>

<!--begin.rcode

# ADJUST WORKING DIRECTORY TO YOUR SITUATION
setwd("D:/Dropbox/Mac&Surf/Programmierkurs Dropb/Data")

load("dataForAnalysis.RData")


unique(dataXrates$D1)

x = unique(dataXrates$D1)[10]
x

D = dataXrates[dataXrates$D1 == x, ]
D = na.omit(D)

plot(D$timeID, D$Value, type = "l")

end.rcode-->


<p>So that's it for this course. I hope you enjoyed it, found it useful, and, most important, you will put everything into practice!</p>



</div> <!-- end of div scriptText -->


<div class='markEnd'> </div> <!-- A last horizontal ruler at the end of the document-->

</div> <!-- end of content div -->

</body>
</html>
